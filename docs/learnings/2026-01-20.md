# Learning Notes - 2026-01-20

## 1. JavaScript Expressions and the "Truthy" Bug

### The Issue
In JavaScript/TypeScript, an assignment (e.g., `error = err`) is an **expression** that returns the value being assigned. When used in an arrow function without curly braces, this value is **implicitly returned**.

### The Symptom
In the `AuthGuard`, we had the following code:
```typescript
.catch((err) => (error = err));

if (canActivate) {
  return true;
}
```
When a guard threw an error, the catch block assigned the error to the variable `error` but also **returned** that error object to `canActivate`. Since objects (including Error objects) are **truthy** in JavaScript, the `if (canActivate)` check passed, and the guard incorrectly allowed the request.

### The Fix
Explicitly return `false` from the catch block to ensure the boolean check fails as expected, while still capturing the error:
```typescript
.catch((err) => {
  error = err;
  return false;
});
```

---

## 2. Expressions vs. Statements in JavaScript

### Expressions
An expression is a piece of code that evaluates to a value. Anything you can assign to a variable or pass to a function is an expression.
- `5 + 5` (Evaluates to 10)
- `getUser()` (Evaluates to the return value)
- `x = 10` (Evaluates to 10)

### Statements
A statement is an instruction to perform an action. Statements do not return values in the same way expressions do.
- `if (...) { ... }`
- `for (...) { ... }`
- `class User {}`

### Why it Matters
Understanding this distinction is critical for arrow functions. `() => value` is a shortcut for `() => { return value; }`. If your "action" is an expression (like assignment), it will be returned unless you wrap it in `{}` and control the return manually.

---

## 3. Multi-Guard Logic (OR Logic)

### How it Works
The `AuthGuard` iterates through a list of guards (e.g., `Bearer`, `API Key`).
1. **Try Each:** It attempts to run each guard one by one.
2. **Short-Circuit on Success:** As soon as one guard returns `true`, the `AuthGuard` returns `true` and the request proceeds. The remaining guards are **never executed**.
3. **Accumulate Errors:** If a guard fails (throws), we catch the error, save it, and continue to the next guard.
4. **Final Failure:** Only if **all** guards fail does the `AuthGuard` throw the last captured error.

### Use Case
This is ideal for "OR" authentication scenarios where a user can provide a Session Cookie **OR** an Authorization Header. It allows for flexible authentication strategies on the same endpoint.

---

## 4. Static Properties and Methods

### What is `static`?
The `static` keyword defines a property or method that belongs to the **Class** itself, rather than to any specific **Instance** (object) created from that class.

### The Analogy: Blueprint vs. House
- **Non-Static (Instance):** Like the color of the walls. Each house (instance) built from the same blueprint can have a different color. You access this via `this.color`.
- **Static:** Like the architect's name on the blueprint. Every house shared the same blueprint and the name is the same for everyone. You access this via `House.architectName`.

### Why use it in `AuthGuard`?
In your code, `private static readonly defaultAuthType = AuthType.Bearer;` is static because:
1. **Shared Constant:** Every request handled by the guard uses the same default auth type. There's no need to create a new copy of this value for every instance of the guard.
2. **Global Access:** It can be accessed within the class using the class name (e.g., `AuthGuard.defaultAuthType`) without needing to worry about the specific context of `this`.

### Comparison Table
| Feature | Instance (Non-Static) | Static |
| :--- | :--- | :--- |
| **Owner** | The Object (Instance) | The Class |
| **Access via** | `this.propertyName` | `ClassName.propertyName` |
| **Memory** | Allocated per object | Allocated once per class |
| **Use Case** | Data unique to one instance | Constants, configuration, or utility helpers |

