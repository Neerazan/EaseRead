# Learning Notes - 2026-01-19

## 1. TypeORM `select: false` and Property Hydration

### The Issue
When an entity column is marked with `select: false`, TypeORM excludes it from default SQL queries for security (e.g., `passwordHash`). However, since the property is defined in the TypeScript class, the resulting object instance still has that property, but its value is `undefined`.

### The Symptom
Passing `user.passwordHash` to `bcrypt.compare()` results in the error:
`Error: data and hash arguments required`
because the hash argument is `undefined`.

### The Fix
Explicitly select the hidden column when needed:
- **FindOptions:** `this.userRepository.findOne({ where: { ... }, select: ['id', 'passwordHash'] })`
- **QueryBuilder:** `.addSelect('user.passwordHash')`

---

## 2. NestJS `@Res({ passthrough: true })`

### The Problem with `@Res()`
Normally, if you inject the `@Res()` decorator in a controller method, NestJS loses control of the response. You become responsible for calling `res.send()` or `res.json()`, and the `return` value of the method is ignored.

### The Benefit of `passthrough: true`
Adding `{ passthrough: true }` creates a "hybrid" mode:
1. **Manual Control:** You get access to the native response object to perform low-level operations (like `response.cookie()`).
2. **NestJS Orchestration:** NestJS continues to manage the final response. It will still take your `return` value and send it as the JSON body, and decorators like `@HttpCode` will still function.

### Use Case
Perfect for authentication flows where you need to set Secure/HttpOnly cookies but still want to return a JSON object containing user data or tokens to the client.
