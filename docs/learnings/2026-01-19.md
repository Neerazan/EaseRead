# Learning Notes - 2026-01-19

## 1. TypeORM `select: false` and Property Hydration

### The Issue
When an entity column is marked with `select: false`, TypeORM excludes it from default SQL queries for security (e.g., `passwordHash`). However, since the property is defined in the TypeScript class, the resulting object instance still has that property, but its value is `undefined`.

### The Symptom
Passing `user.passwordHash` to `bcrypt.compare()` results in the error:
`Error: data and hash arguments required`
because the hash argument is `undefined`.

### The Fix
Explicitly select the hidden column when needed:
- **FindOptions:** `this.userRepository.findOne({ where: { ... }, select: ['id', 'passwordHash'] })`
- **QueryBuilder:** `.addSelect('user.passwordHash')`

---

## 2. NestJS `@Res({ passthrough: true })`

### The Problem with `@Res()`
Normally, if you inject the `@Res()` decorator in a controller method, NestJS loses control of the response. You become responsible for calling `res.send()` or `res.json()`, and the `return` value of the method is ignored.

### The Benefit of `passthrough: true`
Adding `{ passthrough: true }` creates a "hybrid" mode:
1. **Manual Control:** You get access to the native response object to perform low-level operations (like `response.cookie()`).
2. **NestJS Orchestration:** NestJS continues to manage the final response. It will still take your `return` value and send it as the JSON body, and decorators like `@HttpCode` will still function.

### Use Case
---

## 3. Atomic Operations with Redis Lua Scripts

### The TOCTOU Problem (Time-of-Check to Time-of-Use)
In refresh token rotation, we often need to check if a token is valid before invalidating (deleting) it. If these are two separate commands (`GET` then `DEL`), a race condition occurs:
1. **Request A** checks token -> Valid.
2. **Request B** checks token -> Valid.
3. **Request A** deletes token and generates **New Token X**.
4. **Request B** deletes token (or nothing) and generates **New Token Y**.

Now, **Token X** is immediately invalidated or overwritten by **Token Y**, breaking the session for User A.

### The Lua Script Solution
Redis handles Lua scripts as a single atomic operation. No other commands can run while the script is executing. This eliminates the "gap" between checking and deleting.

### Implementation Logic
```lua
-- 1. Get the current token ID stored for this user
local currentToken = redis.call("get", KEYS[1])

-- 2. Check if the provided tokenId matches the stored one
if currentToken == ARGV[1] then
    -- 3. If it matches, delete it and return 1 (success)
    return redis.call("del", KEYS[1])
else
    -- 4. Otherwise return 0 (failure)
    return 0
end
```

### Key Benefits
1. **Indivisibility:** Guarantees that the "check and act" happens without interruption.
2. **Reduced Latency:** Reduces network round-trips from two to one.
3. **Data Integrity:** Ensures one-to-one token rotation even under heavy concurrent load.
