# Learning Notes - 2026-01-19

## 1. TypeORM `select: false` and Property Hydration

### The Issue
When an entity column is marked with `select: false`, TypeORM excludes it from default SQL queries for security (e.g., `passwordHash`). However, since the property is defined in the TypeScript class, the resulting object instance still has that property, but its value is `undefined`.

### The Symptom
Passing `user.passwordHash` to `bcrypt.compare()` results in the error:
`Error: data and hash arguments required`
because the hash argument is `undefined`.

### The Fix
Explicitly select the hidden column when needed:
- **FindOptions:** `this.userRepository.findOne({ where: { ... }, select: ['id', 'passwordHash'] })`
- **QueryBuilder:** `.addSelect('user.passwordHash')`

---

## 2. NestJS `@Res({ passthrough: true })`

### The Problem with `@Res()`
Normally, if you inject the `@Res()` decorator in a controller method, NestJS loses control of the response. You become responsible for calling `res.send()` or `res.json()`, and the `return` value of the method is ignored.

### The Benefit of `passthrough: true`
Adding `{ passthrough: true }` creates a "hybrid" mode:
1. **Manual Control:** You get access to the native response object to perform low-level operations (like `response.cookie()`).
2. **NestJS Orchestration:** NestJS continues to manage the final response. It will still take your `return` value and send it as the JSON body, and decorators like `@HttpCode` will still function.

### Use Case
Perfect for scenarios where you need the best of both worlds:
1. **Authentication:** Setting `HttpOnly` and `Secure` cookies for tokens while still returning a JSON object containing user data to the frontend.
2. **Custom Headers:** Adding custom tracking or pagination headers manually while letting NestJS handle the object-to-JSON serialization of the response body.
3. **Dynamic Redirects:** Deciding whether to redirect or send a JSON response based on logic, while still using NestJS interceptors and decorators for the return path.


## 3. Atomic Operations with Redis Lua Scripts

### The TOCTOU Problem (Time-of-Check to Time-of-Use)
In refresh token rotation, we often need to check if a token is valid before invalidating (deleting) it. If these are two separate commands (`GET` then `DEL`), a race condition occurs:
1. **Request A** checks token -> Valid.
2. **Request B** checks token -> Valid.
3. **Request A** deletes token and generates **New Token X**.
4. **Request B** deletes token (or nothing) and generates **New Token Y**.

Now, **Token X** is immediately invalidated or overwritten by **Token Y**, breaking the session for User A.

### The Lua Script Solution
Redis handles Lua scripts as a single atomic operation. No other commands can run while the script is executing. This eliminates the "gap" between checking and deleting.

### Implementation Logic
```lua
-- 1. Get the current token ID stored for this user
local currentToken = redis.call("get", KEYS[1])

-- 2. Check if the provided tokenId matches the stored one
if currentToken == ARGV[1] then
    -- 3. If it matches, delete it and return 1 (success)
    return redis.call("del", KEYS[1])
else
    -- 4. Otherwise return 0 (failure)
    return 0
end
```

### Key Benefits
1. **Indivisibility:** Guarantees that the "check and act" happens without interruption.
2. **Reduced Latency:** Reduces network round-trips from two to one.
3. **Data Integrity:** Ensures one-to-one token rotation even under heavy concurrent load.

---

## 4. Resource Management with Redis TTL

### The Problem: Persistent Stale Data
When storing Refresh Token IDs (or any session data) in Redis, using a plain `SET` command without an expiration time creates two issues:
1. **Resource Leak:** If a user never refreshes their token (e.g., they just close the tab), that key stays in Redis memory forever.
2. **Security Risk:** Stale token IDs remain "active" in the database long after the actual JWT has expired, increasing the attack surface unnecessarily.

### The Solution: TTL (Time-To-Live)
Always set an expiration time that matches or slightly exceeds the lifespan of the associated JWT. In Redis, this is achieved using the `EX` (seconds) or `PX` (milliseconds) flags.

### Implementation
```typescript
async insert(userId: string, tokenId: string, ttl: number): Promise<void> {
  // Use 'EX' to set expiration in seconds
  await this.redisClient.set(this.getKey(userId), tokenId, 'EX', ttl);
}
```

### Why it matters
- **Automatic Cleanup:** Redis automatically deletes the key when the time is up, keeping memory usage lean.
- **Synchronized Expiration:** The stored state dies exactly when the token itself becomes invalid, ensuring consistency between the JWT and our server-side storage.

